---
title: "MS Pen ___ Preprocessing"
author: "<span style='font-size: 17px;'>`r Sys.info()[['user']]`</span><br><span style='font-size: 12px; color:#696969;'>Eberlin Lab, Department of Surgery<br>Baylor College of Medicine</span>"
date: "<span style='font-size: 15px; color: black;'>`r format(Sys.time(), '%B %d, %Y %H:%M')`</span>"
knit: (function(inputFile, encoding) { 
      proj_name <- tools::file_path_sans_ext(basename(inputFile));
      out_dir <- file.path("outputs", paste0(proj_name, "_", Sys.Date()));
      if(!file.exists(out_dir)) {   dir.create(out_dir) };
      rmarkdown::render(inputFile,
                        encoding=encoding, 
                        output_file=file.path(dirname(inputFile), 
                        out_dir, 
                        paste0(format(Sys.time(), "%Y-%m-%d_%H.%M"),"_", proj_name, ".html"))) 
                        })

output: 
  html_document:
    keep_md: yes
    df_print: paged
    toc: false
geometry: margin=0.5in
editor_options: 
  markdown: 
    wrap: 72
---

```{=html}
<style type="text/css">
.main-container {
max-width: 1600px;
margin-left: auto;
margin-right: auto;
}
</style>
```

```{css, echo=FALSE}
h1,h2, h3, h4, h5, p {
text-align: center;
font-size: 20px;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, echo = FALSE, cache = TRUE)
## cache set to TRUE because sometimes otherwise the files directory disappears for some users
```

```{r libraries, message = FALSE, warning = FALSE}
library(rmarkdown)
library(knitr)
library(kableExtra)
library(ggpubr)

library(tidyverse)
library(reshape2)
library(readxl)
library(rawrr)
library(sqldf)

library(stringr)
library(doParallel)
library(fcluster)
library(johnfuncs)
```

```{r user input}
## Full path to folder with sample files (excel or csv, or raw Thermo files)
sample_dir <- gsub("\\\\", "/", r"(C:\Users\fjackobs\Desktop\MSPen_script_test_data\raw)")

## Full path to feature list, otherwise NA
feature_file <- NA

## Full path to background peak list, otherwise NA
background_file <- NA

## ---------------------------------------------------------------------------

## Scan numbers to import when using raw Thermo files
scans <- 1
#scans <- 50:500 ## number of scans to extract from each raw file

## Mass range to filter
mass_range <- c(100,1000)

## Peak Alignment Method: "clustering", "binning", or "featurelist"
peak_alignment_method <- "clustering"

## If peak alignment method is "clustering":
clust_h <- 0.05 ## Height at which to cut dendrogram to determine clusters

## If peak alignment method is "featurelist":
ppm_error <- 5 ## Mass error tolerance of sample peaks to match to feature peaks

## Normalization Method: "tic", "maxpeak", "median", "medianlog", or "none"
normalization_method <- "tic" 
```

```{r create output directory, include = FALSE}
proj_name <- tools::file_path_sans_ext(basename(rstudioapi::getSourceEditorContext()$path))

out_dir <- file.path("outputs", paste0(proj_name, "_", Sys.Date()))

if(!file.exists(out_dir)) {   
  dir.create(out_dir, recursive = TRUE) 
  }

files_dir <- file.path(out_dir, paste0(format(Sys.time(), "%Y-%m-%d_%H.%M"), "_", proj_name, "_files"))

if(!file.exists(files_dir)) {   
  dir.create(files_dir, recursive = TRUE) 
  }
```

```{r other settings}
## Signal-to-Noise Ratio Threshold
SNR_thresh <-  2

## Peak filter
p <- 0.10 ## A peak present in fewer than p*100% of samples is removed, default = 0.10 or 10%

## Randomization seed
seed <- 1234
```

```{r classes}
## read sub-directories for class names
classes <- gsub(file.path(sample_dir, "/"), "", list.dirs(sample_dir, recursive=FALSE), fixed=TRUE)
```

```{r file extension}
sample_file_ext <- unique(unlist(
  lapply(classes, function(x) 
    tools::file_ext(list.files(file.path(sample_dir, "/",x,"/"))))))[1] 
## only take the first file extension type...tbd if more than one type in folder
```

```{r file names}
file_name_list <- lapply(classes, function(x) 
  list.files(path = file.path(sample_dir,x), pattern = paste0("*.", sample_file_ext), full.names = TRUE))

## Ensure patient ordering is consistent across different OSes.
file_name_list <- lapply(file_name_list, sort)
```

```{r sample names}
sample_names_list <- lapply(file_name_list, function(x) tools::file_path_sans_ext(basename(x)))
names(sample_names_list) <- classes

sample_names <- unlist(sample_names_list)

sample_names_df <- purrr::map_df(sample_names_list, ~as.data.frame(.x), .id="id")
colnames(sample_names_df) <- c("class", "sample_name")
```

```{r csv data}
if (sample_file_ext == "csv") {
  fixed_objects <- list(mass_range = mass_range, SNR_thresh = SNR_thresh)
  
  spectra_list <- nested_process_csv(file_name_list, fixed_objects)
  
  ## Set sample names and classes of spectra_list
  spectra_list <- lapply(seq_along(spectra_list), \(i) setNames(spectra_list[[i]], sample_names_list[[i]]))
  names(spectra_list) <- classes
}
```

```{r excel data}
if (sample_file_ext == "xlsx") {
  fixed_objects <- list(mass_range = mass_range, SNR_thresh = SNR_thresh)
  
  spectra_list <- nested_process_xlsx(file_name_list, fixed_objects)
  
  ## Set sample names and classes of spectra_list
  spectra_list <- lapply(seq_along(spectra_list), \(i) setNames(spectra_list[[i]], sample_names_list[[i]]))
  names(spectra_list) <- classes
}
```

```{r raw Thermo data}
## If sample files are raw Thermo
if (sample_file_ext == "raw") {
  fixed_objects <- list(scans = scans, mass_range = mass_range, SNR_thresh = SNR_thresh)
  
  spectra_list <- nested_process_raw_thermo(file_name_list, fixed_objects)
  
  ## Set sample names and classes of spectra_list
  spectra_list <- lapply(seq_along(spectra_list), \(i) setNames(spectra_list[[i]], sample_names_list[[i]]))
  names(spectra_list) <- classes
}
```

```{r peak alignment clustering}
## If peak alignment method is clustering
if (peak_alignment_method == "clustering") {
  
  clust_int_method  <-  "sumints" ## Handling of multiple intensities aggregating to one cluster centroid: "sumints" or "maxint"
  
  all_mz <- spectra_list %>%
    flatten() %>%
    map(~ round(.x$m.z, 3)) %>%
    unlist() %>%
    sort()
  
  ## Cluster peaks into centroids
  tree <- fcluster(all_mz)
  clust_mz <- fcutree(all_mz, tree, h=clust_h)
  clustMZ <- sort(clust_mz$cen)
  
  ## Match cluster centroids to sample peaks
  clusterMatrixList <- lapply(spectra_list, function(x, y, z, w) 
    get_cluster_matrix(x, y, z, w), y=clustMZ, z = clust_h, w = clust_int_method)
  
  preprocList <- lapply(clusterMatrixList, function(x) as.matrix(get_data_matrix_clustering(x)))
  
  aligned_spectra <- do.call(rbind, preprocList)
  
  colnames(aligned_spectra) <- clustMZ
  rownames(aligned_spectra) <- sample_names
  
  ## FILTER #3: REMOVE RARE/UNCOMMON PEAKS PRESENT < 10% SAMPLES
  mz_count_filter <- colSums(aligned_spectra != 0) > as.integer(nrow(aligned_spectra)*p)
  aligned_spectra <- aligned_spectra[, mz_count_filter]
  
  filtered_mz <- clustMZ[mz_count_filter]
  
  centroid_min_max <- identify_clusters(clust_mz, all_mz)
  
  ## FILTER #4: REMOVE BACKGROUND PEAKS (IF BACKGROUND FILE PRESENT)
  if (!is.na(background_file)) {
    ## Read background file, check if it has a header
    if(is.character(read.csv(background_file, header = FALSE, nrows = 1)[1,1]) == TRUE) {
      bg_mz <- read.csv(background_file, header = TRUE)
    } else {
      bg_mz <- read.csv(background_file, header = FALSE)
    }
    
    colnames(bg_mz) <- "mz"
    
    # match bg_mz to cluster centroid
    bg_centroids <- sqldf("SELECT centroid_min_max.centroid, bg_mz.*
          FROM bg_mz,centroid_min_max
          WHERE bg_mz.mz BETWEEN centroid_min_max.min_mz AND centroid_min_max.max_mz")
    
    ## Remove peaks from aligned_spectra that are in bg_mz_centroid
    bg_ind <- which(filtered_mz %in% unique(bg_centroids$centroid))
    
    filtered_mz <- filtered_mz[-c(bg_ind)]
    aligned_spectra <- aligned_spectra[, -c(bg_ind)]
  }
}
```

```{r peak alignment binning}
if (peak_alignment_method == "binning") {
  ## Hard coded that m/z values are rounded to 2 decimal places and intensities of peaks that fall into the same bin are summed (by John Lin). 
  ## TBD about changing this - FEJ 2024-09-06
  
  all_mz <- spectra_list %>%
    flatten() %>%
    map(~ round(.x$m.z, 2)) %>% ## round to 2 decimal places
    unlist() %>%
    sort() 
  
  ## FILTER #3: REMOVE RARE/UNCOMMON PEAKS PRESENT < 10% SAMPLES
  mz_count <- table(all_mz)
  mz_count_filter <- mz_count > as.integer(length(sample_names)*p)
  filtered_mz <- as.numeric(names(mz_count)[mz_count_filter])
  
  ## Bin sample peaks
  preprocList <- lapply(spectra_list, function(x,z) get_data_matrix_binning(x,z), z=filtered_mz)
  
  aligned_spectra <- do.call(rbind, preprocList)
  
  colnames(aligned_spectra) <- filtered_mz
  rownames(aligned_spectra) <- sample_names
  
  ## FILTER #4: REMOVE BACKGROUND PEAKS (IF BACKGROUND FILE PRESENT)
  if (!is.na(background_file)) {
    ## Read background file, check if it has a header
    if(is.character(read.csv(background_file, header = FALSE, nrows = 1)[1,1]) == TRUE) {
      bg_mz <- round(read.csv(background_file, header = TRUE),2)
    } else {
      bg_mz <- round(read.csv(background_file, header = FALSE), 2)
    } ## round to 2 decimal places for binned values
    
    aligned_spectra <- aligned_spectra[, !(colnames(aligned_spectra) %in% bg_mz)]
    filtered_mz <- as.numeric(colnames(aligned_spectra))
  }
  
  centroid_min_max <- NA
}
```

```{r peak alignment feature list}
if (peak_alignment_method == "featurelist") {
  background_file <- NA
  
  ## Read file with feature peaks
  feature_df <- read.csv(feature_file, header = TRUE)
  feature_peaks <- feature_df[,1]
  
  ## Feature mz plus/minus instrument mass error, round to 3 decimal places
  mass_error <- (ppm_error * feature_peaks)/1e6
  
  feature_peaks <- data.frame(feature_mz = feature_peaks,
                              mass_error = mass_error,
                              mass_error_lower = round(feature_peaks - mass_error,3),
                              mass_error_upper = round(feature_peaks + mass_error,3))
  
  ## fixed objects for exporting to parallel computing
  fixed_objects <- list(feature_peaks = feature_peaks)
  
  feature_matched_spectra <- nested_feature_peak_alignment(spectra_list, fixed_objects)
  
  ## turn list of lists into dataframe
  feature_matched_spectra <- lapply(feature_matched_spectra, function(x) x %>%
                                      reduce(full_join,by = "feature_mz")) %>% 
    reduce(full_join,by = "feature_mz")
  
  ## sort by target_mz
  feature_matched_spectra <- feature_matched_spectra[order(feature_matched_spectra$feature_mz), ]
  
  filtered_mz <- feature_matched_spectra$feature_mz
  
  ## feature_mass column to rownames
  feature_matched_spectra <- feature_matched_spectra %>% 
    remove_rownames %>% 
    column_to_rownames(var = "feature_mz") %>% 
    as.data.frame()
  
  ## Add sample names as column names
  colnames(feature_matched_spectra) <- sample_names
  
  ## Replace NA with 0
  feature_matched_spectra <- replace(feature_matched_spectra, is.na(feature_matched_spectra), 0)
  
  ## Transpose so rows are samples and columns are masses
  aligned_spectra <- t(feature_matched_spectra)
  
  ## remove columns that are only zeros
  zero_col <- which(colSums(aligned_spectra==0) == nrow(aligned_spectra))
  if (length(zero_col) != 0) {
    filtered_mz <- filtered_mz[-c(zero_col)]
    aligned_spectra <- aligned_spectra[, -c(zero_col)]
  }
  
  centroid_min_max <- NA
  
  save(aligned_spectra, filtered_mz, file = file.path(files_dir, paste0("04_aligned_spectra.RData")))
}
```


```{r yall}
## create yall object 
yall <- foreach(i = 1:length(file_name_list), .combine = c) %do% {
  rep(i, length(file_name_list[[i]])) }

## factorize yall
yall <- factor(yall,levels=c("1","2"),labels = classes)
```

```{r}
save(mass_range, peak_alignment_method, clust_h, normalization_method,
     classes, file_name_list, sample_names, filtered_mz, yall, 
     file = file.path(files_dir, paste0("00_", proj_name, "_Robjects_for_analysis.RData")))
```

<br>

#### **Preprocessing and Statistical Model Settings**

```{r chunk3, fig.align = "center"}
if (peak_alignment_method == "clustering") {
  cluster_bin_size <- c("Cluster Height:", clust_h)
} else if (peak_alignment_method == "binning") {
  cluster_bin_size <- c("Bin Size:", "0.01")
} else if (peak_alignment_method == "featurelist") {
  cluster_bin_size <- c("Peak Mass Error:", paste0(ppm_error, " ppm"))
}

if (is.null(background_file)) {
  bg_exclusion <- "no"
} else if (!is.null(background_file)) {
  bg_exclusion <- "yes"
}

settings_df <- rbind(#c("SNR Threshold:", SNR_thresh),
                     c("Mass Range:", paste0('<i>m/z</i> ', mass_range[1], " - ", mass_range[2])),
                     c("Peak Alignment Method:", peak_alignment_method),
                     cluster_bin_size,
                     c("Background Peak Exclusion:", bg_exclusion),
                     c("Normalization Method:", normalization_method))

kable(settings_df,
      row.names = FALSE,
      align = "l",
      format = "html",
      escape = FALSE)%>%
  column_spec(1:2, width = "3in")%>% 
  kable_styling(full_width = FALSE, 
                font_size = 14)
```

<br>

#### **Session Info**

```{r}
sessionInfo()
```

