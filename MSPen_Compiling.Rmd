---
title: "DESI Compiling"
author: "Jacob Mardick"
date: "`r format(Sys.time(), '%B %d, %Y %H:%M')`"
knit: (function(inputFile, encoding) { 
      proj_name <- tools::file_path_sans_ext(basename(inputFile));
      out_dir <- file.path("outputs", paste0(proj_name, "_", Sys.Date()));
      if(!file.exists(out_dir)) {   dir.create(out_dir) };
      rmarkdown::render(inputFile,
                        encoding=encoding, 
                        output_file=file.path(dirname(inputFile), 
                        out_dir, 
                        paste0(format(Sys.time(), "%Y-%m-%d_%H.%M"),"_", proj_name, ".html"))) 
                        })

output: 
  html_document:
    keep_md: yes
    df_print: paged
    toc: false
geometry: margin=0.5in
editor_options: 
  markdown: 
    wrap: 72
---

```{=html}
<style type="text/css">
.main-container {
max-width: 1600px;
margin-left: auto;
margin-right: auto;
}
</style>
```

```{css, echo=FALSE}
h1, h2, h3, h4, h5 {
font-size: 20px;
}

h1, h2, h3, h4, h5, p {
text-align: center;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, echo = FALSE, cache = FALSE)
```

```{r libraries, message = FALSE, warning = FALSE}
library(rmarkdown)
library(knitr)
library(kableExtra)
library(ggpubr)

library(tidyverse)
library(reshape2)
library(readxl)
library(rawrr)
library(sqldf)

library(stringr)
library(doParallel)
library(fcluster)
library(johnfuncs)

library(caret) ## automates supervised learning (predictive modeling)
library(glmnet) ## for training, cross validation, and testing model
library(pROC) ## for plotting ROC curve
library(scales) ## for integer y-axis on histogram
```

```{r user input}
## Mass range to filter
mass_range <- c(100,1000)

## Peak Alignment Method: "clustering"
peak_alignment_method <- "clustering"

## If peak alignment method is "clustering":
## Height at which to cut dendrogram to determine clusters
clust_h <- 0.05

## Method to handle many intensities in one cluster centroid: 
## sum the intensities of peaks in one cluster centroid ("sumints", default) 
## or use the max intensity ("maxint")
clust_int_method  <-  "sumints"

## Normalization Method: "tic", "maxpeak", "median", "medianlog", or "none"
normalization_method <- "tic" 

## Full path to background peak list, otherwise NULL
background_file <- NULL
```

```{r create directory for output files, include = FALSE}
proj_name <- tools::file_path_sans_ext(basename(rstudioapi::getSourceEditorContext()$path))

out_dir <- file.path("outputs", paste0(proj_name, "_", Sys.Date()))

if(!file.exists(out_dir)) {   
  dir.create(out_dir, recursive = TRUE) 
  }

files_dir <- file.path(out_dir, paste0(format(Sys.time(), "%Y-%m-%d_%H.%M"), "_", proj_name, "_files"))

if(!file.exists(files_dir)) {   
  dir.create(files_dir, recursive = TRUE) 
  }
```

```{r load tissue files}
## Load all tissue data from individual preprocessing scripts (not peak matched yet)

## Brain Tissue
brain_env <- new.env()
load("outputs/MSPen_Brain_Preprocessing_2025-10-14/2025-10-14_15.35_MSPen_Brain_Preprocessing_files/01_spectra-list.RData", envir = brain_env)
brain_spectra_list <- brain_env$spectra_list
```

```{r Clustering Peak Alignment}
## If peak alignment method is clustering
if (peak_alignment_method == "clustering") {
  
  ## List of all m/z in each class
  #classMZList <- lapply(dataList, function(x) round(sort(extract_peaks(x)), 3))
  ## round mass to 3 decimal places b/c mass accuracy of instrument is ~ 1 ppm?
  
  ## If background peak list: add background peaks to clustering
  if (!is.null(background_file)) {
    bg_mz <- unlist(read.csv(background_file, header = FALSE))
    
    sample_mz <-sort(unlist(lapply(dataList, function(x) round(sort(extract_peaks(x)), 3))))
    
    all_mz <- sort(c(bg_mz, sample_mz))
    
  } else { ## If no background peak list
    all_mz <- sort(unlist(lapply(dataList, function(x) round(sort(extract_peaks(x)), 3))))
  }
  
  ## Cluster peaks into centroids
  tree <- fcluster(all_mz)
  clust_mz <- fcutree(all_mz, tree, h=clust_h)
  clustMZ <- sort(clust_mz$cen)
  
  ## Match cluster centroids to sample peaks
  clusterMatrixList <- lapply(dataList, function(x, y, z, w) 
    get_cluster_matrix(x, y, z, w), y=clustMZ, z = clust_h, w = clust_int_method)
  
  preprocList <- lapply(clusterMatrixList, function(x) get_data_matrix_clustering(x))
  
  save(preprocList, file = file.path(files_dir, 
                                 paste0("03_", peak_alignment_method,
                                        "_h", clust_h, clust_int_method,
                                        "_preprocList.RData")))
  
  aligned_spectra <- do.call(rbind, preprocList)
  
  colnames(aligned_spectra) <- clustMZ
  rownames(aligned_spectra) <- pi$pixel_name
  
  ## FILTER #1: REMOVE RARE/UNCOMMON PEAKS PRESENT < 10% SAMPLES
  mz_count_filter <- Matrix::colSums(aligned_spectra != 0) > as.integer(nrow(aligned_spectra)*0.10)
  aligned_spectra <- aligned_spectra[, mz_count_filter]

  ## FILTER #2: REMOVE BACKGROUND PEAKS (IF BACKGROUND FILE PRESENT)
  if (!is.null(background_file)) {
    ## match bg_mz to cluster centroid
    temp_a <- data.frame(cluster_id = clust_mz$cluster_index,
                         all_mz = all_mz)
    
    temp_b <- data.frame(clust_centroid = clust_mz$centroid, 
                         cluster_id = unique(clust_mz$cluster_index)[order(unique(clust_mz$cluster_index))])
    
    temp_c <- merge(temp_a, temp_b, by = "cluster_id")
    
    bg_centroids <- unique(temp_c[temp_c$all_mz %in% bg_mz, ])
    
    ## Remove peaks from aligned_spectra that are in bg_mz_centroid
    aligned_spectra <- aligned_spectra[, !(colnames(aligned_spectra) %in% bg_centroids$clust_centroid)]
  }
  filtered_mz <- as.numeric(colnames(aligned_spectra))
  
  # FILTER #3: RETAIN PEAKS WITHIN MASS RANGE
  mz_range_filter <-  filtered_mz > mass_range[1] & filtered_mz < mass_range[2]
  aligned_spectra <- aligned_spectra[, mz_range_filter]
  
  filtered_mz <- as.numeric(colnames(aligned_spectra))
  
  save(aligned_spectra, filtered_mz, file = file.path(files_dir, paste0("04_aligned_spectra.RData")))
}
```

```{r yall}
normal_labels <- c("ExtractedDESI_NLB", "1NL", "Normal")

yall <- ifelse(pi$className %in% normal_labels, "Normal", "Cancer")
yall <- factor(yall, levels = c("Normal", "Cancer"))
```

```{r normalization}
xall <- normalize_pixel(as.matrix(aligned_spectra), normalization_method)
```

```{r save}
save(mass_range, peak_alignment_method, clust_h, clust_int_method, normalization_method, background_file, dataList, pixelInfoList, pi, xall, yall, file = file.path(files_dir, paste0("compiled_data_input.RData")))
```