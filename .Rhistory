plot1 <- ggplot(pixel_counts, aes(x = tissue, y = n_pixels, fill = class)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Tissue Type", y = "Pixel Count", fill = "Class") +
scale_y_continuous(breaks = seq(0, max(pixel_counts$n_pixels), by = 100)) +
theme_minimal() +
theme(
axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
axis.text.y = element_text(size = 14),
axis.title.x = element_text(size = 16),
axis.title.y = element_text(size = 16),
legend.title = element_text(size = 16),
legend.text = element_text(size = 14),
legend.position = "right"
)
plot1
plot1 <- ggplot(pixel_counts, aes(x = tissue, y = n_pixels, fill = class)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Tissue Type", y = "Pixel Count", fill = "Class") +
scale_y_continuous(breaks = seq(0, 2000, by = 100)) +
theme_minimal() +
theme(
axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
axis.text.y = element_text(size = 14),
axis.title.x = element_text(size = 16),
axis.title.y = element_text(size = 16),
legend.title = element_text(size = 16),
legend.text = element_text(size = 14),
legend.position = "right"
)
plot1
ggsave(plot1,
width = 9,        # wider than default
height = 6,        # adjust as needed for aspect ratio
units = "in",      # specify inches
dpi = 300,
file = file.path(files_dir, paste0("pixelcounts_stratified.png")))
plot1 <- ggplot(pixel_counts, aes(x = tissue, y = n_pixels, fill = class)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Tissue Type", y = "Pixel Count", fill = "Class") +
scale_y_continuous(breaks = seq(0, 2000, by = 100), limits = c(0, 2000)) +
theme_minimal() +
theme(
axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
axis.text.y = element_text(size = 14),
axis.title.x = element_text(size = 16),
axis.title.y = element_text(size = 16),
legend.title = element_text(size = 16),
legend.text = element_text(size = 14),
legend.position = "right"
)
ggsave(plot1,
width = 9,        # wider than default
height = 6,        # adjust as needed for aspect ratio
units = "in",      # specify inches
dpi = 300,
file = file.path(files_dir, paste0("pixelcounts_stratified.png")))
sample_counts <- pi %>%
distinct(name, tissue, class) %>%
group_by(tissue, class) %>%
summarize(n_samples = n(), .groups = "drop")
plot2 <- ggplot(sample_counts, aes(x = tissue, y = n_samples, fill = class)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Tissue Type", y = "Sample Count", fill = "Class") +
scale_y_continuous(breaks = seq(0, max(pixel_counts$n_pixels), by = 5)) +
theme_minimal() +
theme(
axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
axis.text.y = element_text(size = 14),
axis.title.x = element_text(size = 16),
axis.title.y = element_text(size = 16),
legend.title = element_text(size = 16),
legend.text = element_text(size = 14)
)
ggsave(plot2,
width = 6,        # wider than default
height = 6,        # adjust as needed for aspect ratio
units = "in",      # specify inches
dpi = 300,
file = file.path(files_dir, paste0("samplecounts_stratified.png"))
)
ggsave(plot2,
width = 9,        # wider than default
height = 6,        # adjust as needed for aspect ratio
units = "in",      # specify inches
dpi = 300,
file = file.path(files_dir, paste0("samplecounts_stratified.png"))
)
## save index of lambda value that gives minimum cvm (mean cross-validated error)
min_lambda_index <- which(cvmodel$lambda == cvmodel$lambda.min)
## 1/(1+e^(-preval)) is the inverse of the link function?
cv_predictions <- 1/(1+exp(-cvmodel$fit.preval[,min_lambda_index]))
## build ROC for training data using minLamIdx
roc_curve <- roc(
ytrain,
cv_predictions )
## create dataframe from ROC object to create plot for trade off
## of accuracy, sensitivity, and specificity
roc_df <- data.frame(
cutoff = roc_curve$thresholds,
sensitivity = roc_curve$sensitivities,
specificity = roc_curve$specificities )
roc_df$accuracy <- (roc_df$sensitivity*length(roc_curve$cases) +
roc_df$specificity*length(roc_curve$controls)) / (length(roc_curve$cases) +
length(roc_curve$controls) )
## plot trade off of accuracy, sensitivity, and specificity
roc_metrics <- ggplot(roc_df) + geom_line(aes(cutoff, sensitivity, col = "Sensitivity")) +
geom_line(aes(cutoff, specificity, col = "Specificity")) +
geom_line(aes(cutoff, accuracy, col = "Accuracy")) +
labs(x = "cutoff", y = "%", color="") +
ggtitle("Trade off of performance metrics for determining threshold cutoff value")
## Identify Threshold Coordinates where Accuracy, Sensitivity, and Specificity Cross
## Set threshold for labeling classes --> balance of true positive and false positive rates.
best_threshold <- as.double(coords(roc_curve,
"best", ## coordinates for best threshold value
ret = "threshold", ## coordinates to return
best.method = "youden" )[1,1]) ## optimal cut-off is the threshold that maximizes the distance to the identity (diagonal) line
## predict classes based on threshold
cv_p_thresh <- ifelse(cv_predictions < best_threshold, levels(ytrain)[1], levels(ytrain)[2])
cv_p_class <- factor(cv_p_thresh, levels(ytrain))
## simple confusion matrix table
cv_cm <- table(True=ytrain,
Predict=cv_p_class)
## Get predictions from cv.glmnet
fit_vals <- cvmodel$fit.preval[, min_lambda_index]
## Only keep those rows with non-NA predictions
valid_idx <- !is.na(fit_vals)
## Convert to probabilities
cv_predictions <- 1 / (1 + exp(-fit_vals[valid_idx]))
## Predicted classes
cv_p_class <- ifelse(cv_predictions < best_threshold, "Normal", "Cancer")
## True labels (same filtering)
ytrain_valid <- ytrain[valid_idx]
sample_names_valid <- sample_names[train_idx][valid_idx]
## Create dataframe
train_df <- data.frame(
file_name = sample_names_valid,
true_class = ytrain_valid,
prediction_class = cv_p_class,
probability = cv_predictions
)
classes <- levels(yall)
coef <- reportCoef(xall, model, cvmodel$lambda.min, filtered_mz, classes)
View(coef)
test_p <- predict(model,
xtest,
s = cvmodel$lambda.min, ## Value of the penalty parameter lambda
## at which predictions are required
type = "response" ) ## to get prediction values rather than linker function values
test_p_thresh <- ifelse(test_p < best_threshold, classes[1], classes[2])
test_p_class <- factor(test_p_thresh, levels(ytest))
## simple confusion matrix table
test_cm <- table(True=ytest,
Predict=test_p_class)
test_df <- data.frame(
file_name = pi$name[test_idx],
true_class = ytest,
prediction_class = test_p_class,
probability = as.numeric(test_p)
)
rownames(test_df) <- NULL
train_wrong_preds <- train_df %>%
filter(true_class != prediction_class)
test_wrong_preds <- test_df %>%
filter(true_class != prediction_class)
## training set files
write.csv(cv_cm,
file = file.path(files_dir, "train_cm.csv"))
write.csv(train_df,
row.names = FALSE,
file.path(files_dir, "train_preds.csv"))
write.csv(train_wrong_preds,
row.names = FALSE,
file.path(files_dir, "misclassified_train_preds.csv"))
write.csv(coef,
file.path(files_dir, "coefficients.csv"))
## test set files
write.csv(test_cm,
file = file.path(files_dir, "test_cm.csv"))
write.csv(test_df,
row.names = FALSE,
file.path(files_dir, "test_preds.csv"))
write.csv(test_wrong_preds,
row.names = FALSE,
file.path(files_dir, "misclassified_test_preds.csv"))
plot(cvmodel)
title("Cross-Validation Curve: Binomial Family", line = 6)
png(filename=file.path(files_dir, "cv_plot.png"))
plot(cvmodel)
title("Cross-Validation Curve: Binomial Family", line = 6)
dev.off()
png(filename=file.path(files_dir, "cv_plot.png"))
plot(cvmodel)
title("Cross-Validation Curve: Binomial Family", line = 6)
dev.off()
png(filename = file.path(files_dir, "cv_plot.png"), width = 1000, height = 800, res = 150)
plot(cvmodel)
title("Cross-Validation Curve: Binomial Family", line = 3, cex.main = 1.6)
dev.off()
png(filename=file.path(files_dir, "roc_plot.png"))
plot(roc_curve,
print.thres="best",
print.thres.best.method="youden",
print.auc=TRUE,
auc.polygon=TRUE,
main = "ROC Curve")
dev.off()
ggsave(roc_metrics, filename = file.path(files_dir, "roc_metrics_thresh.png"))
if (peak_alignment_method == "clustering") {
cluster_bin_size <- c("Cluster Height:", clust_h)
} else if (peak_alignment_method == "binning") {
cluster_bin_size <- c("Bin Size:", "0.01")
} else if (peak_alignment_method == "featurelist") {
cluster_bin_size <- c("Peak Mass Error:", paste0(ppm_error, " ppm"))
}
if (is.null(background_file)) {
bg_exclusion <- "no"
} else if (!is.na(background_file)) {
bg_exclusion <- "yes"
}
train_fraction <- 0.7
settings_df <- rbind(#c("SNR Threshold:", SNR_thresh),
c("Mass Range:", paste0('<i>m/z</i> ', mass_range[1], " - ", mass_range[2])),
c("Peak Alignment Method:", peak_alignment_method),
cluster_bin_size,
c("Background Peak Exclusion:", bg_exclusion),
c("Normalization Method:", normalization_method),
c("Randomization Seed:", seed),
c("Train/Test Split:", paste0((train_fraction*100),"/",(100-(train_fraction*100)))),
c("Elastic Net Alpha:", "1 (LASSO)"))
classes2 <- tools::toTitleCase(gsub("_", " ", classes))
#classes2 <- unlist(lapply(str_split(classes, pattern  = " "), tail, n = 1L)) ## If class is last element of full class name
#classes2 <- unlist(lapply(str_split(classes, pattern  = "_"), tail, n = 1L)) ## If class is last element of full class name
kable(settings_df,
row.names = FALSE,
align = "l",
format = "html",
escape = FALSE)%>%
column_spec(1:2, width = "3in")%>%
kable_styling(full_width = F)
#cols <- rev(c(hue_pal()(2))) ## teal, salmon
cols <- c(hue_pal()(2)) ## salmon, teal
cv_cm <- as.data.frame.matrix(cv_cm)
test_cm <- as.data.frame.matrix(test_cm)
cv_cm <- cbind(c("True", "True"),
classes2,
cv_cm)
test_cm <- cbind(c("True", "True"),
classes2,
test_cm)
rownames(cv_cm) <- NULL
rownames(test_cm) <- NULL
colnames(cv_cm) <- c(".", "  ", classes2)
colnames(test_cm) <- c(".", "  ", classes2)
names(cv_cm)[1] <- cell_spec(names(cv_cm)[1], color = "white")
names(test_cm)[1] <- cell_spec(names(test_cm)[1], color = "white")
cv_accuracy <- rbind(c(paste0(classes2[1], " Recall: "),
paste0(format(round((cv_cm[1,3]/rowSums(cv_cm[,3:4])[1])*100, 1), nsmall = 1), "%")),
c(paste0(classes2[2], " Recall: "),
paste0(format(round((cv_cm[2,4]/rowSums(cv_cm[,3:4])[2])*100,1), nsmall = 1), "%")),
c("Overall Accuracy: ",
paste0(format(round(((cv_cm[1,3] + cv_cm[2,4])/sum(cv_cm[, 3:4]))*100, 1), nsmall = 1), "%")))
test_accuracy <- rbind(c(paste0(classes2[1], " Recall: "),
paste0(format(round((test_cm[1,3]/rowSums(test_cm[,3:4])[1])*100, 1), nsmall = 1), "%")),
c(paste0(classes2[2], " Recall: "),
paste0(format(round((test_cm[2,4]/rowSums(test_cm[,3:4])[2])*100,1), nsmall = 1), "%")),
c("Overall Accuracy: ",
paste0(format(round(((test_cm[1,3] + test_cm[2,4])/sum(test_cm[, 3:4]))*100, 1), nsmall = 1), "%")))
if(normalization_method == "median"){
coef2 <- data.frame(cbind(c("Intercept", format(as.numeric(rownames(coef[2:nrow(coef),])), nsmall = 3)), as.numeric(coef[, 1])))
}else {
coef2 <- data.frame(cbind(c("Intercept", format(as.numeric(rownames(coef[2:nrow(coef),])), nsmall = 3)), format(round(as.numeric(coef[, 1]),3), nsmall = 3)))
}
colnames(coef2) <- c("Features", paste0("Weights (", classes2[2], ")"))
kable(cv_cm,
align = "c",
format = "html",
escape = FALSE) %>%
kable_styling(full_width = FALSE) %>%
add_header_above(c("", " ", "Predict" = 2)) %>%
column_spec(1, bold = TRUE) %>%
column_spec(2, bold = TRUE) %>%
collapse_rows(columns = 1) %>%
column_spec(3, background = "#c3fcb5")
kable(cv_accuracy,
row.names = FALSE,
align = "r") %>%
column_spec(1, bold = TRUE) %>%
kable_minimal(full_width = FALSE,
bootstrap_options = "condensed",
html_font = "Calibri",
font_size = 16)
kable(cv_cm,
align = "c",
format = "html",
escape = FALSE) %>%
kable_styling(full_width = FALSE) %>%
add_header_above(c("", " ", "Predict" = 2)) %>%
column_spec(1, bold = TRUE) %>%
column_spec(2, bold = TRUE) %>%
collapse_rows(columns = 1) %>%
column_spec(3, background = "#c3fcb5")
kable(cv_cm,
align = "c",
format = "html",
escape = FALSE) %>%
kable_styling(full_width = FALSE, font_size = 16) %>%
add_header_above(c("", " ", "Predicted" = 2)) %>%  # corrected label
column_spec(1, bold = TRUE) %>%
column_spec(2, bold = TRUE) %>%
column_spec(3, background = "#c3fcb5") %>%  # highlight actual positive
collapse_rows(columns = 1)
c
kable(cv_cm,
align = "c",
format = "html",
escape = FALSE) %>%
kable_styling(full_width = FALSE) %>%
add_header_above(c("", " ", "Predict" = 2)) %>%
column_spec(1, bold = TRUE) %>%
column_spec(2, bold = TRUE) %>%
collapse_rows(columns = 1) %>%
column_spec(3, background = "#c3fcb5")
kable(cv_accuracy,
row.names = FALSE,
align = "r") %>%
column_spec(1, bold = TRUE) %>%
kable_minimal(full_width = FALSE,
bootstrap_options = "condensed",
html_font = "Calibri",
font_size = 16)
install.packages("webshot2")
webshot2::install_phantomjs()
webshot2::webshot_install()
kable(test_cm,
align = "c",
format = "html",
escape = FALSE) %>%
kable_styling(full_width = FALSE) %>%
add_header_above(c("", "","Predict" = 2)) %>%
column_spec(1, bold = TRUE) %>%
column_spec(2, bold = TRUE) %>%
collapse_rows(columns = 1) %>%
column_spec(3, background = "#c3fcb5")
kable(test_accuracy,
row.names = FALSE,
align = "r") %>%
column_spec(1, bold = TRUE) %>%
kable_minimal(full_width = FALSE,
bootstrap_options = "condensed",
html_font = "Calibri",
font_size = 16)
plot(roc_curve,
print.thres="best",
print.thres.best.method="youden",
print.auc=TRUE,
auc.polygon=TRUE,
main = "ROC")
coef2 %>%
kable(
row.names = FALSE,
align = "c") %>%
kable_styling(full_width = FALSE,
font_size = 14) %>%
column_spec(1:2,width = "2in")
## remove intercept row
#intercept <- paste0("Intercept:", coef2[1, 2])
intercept <- coef2[1, 2]
## split features into positive and negative
pos_features <- coef2[which(as.numeric(coef2[[2]]) > 0), ]
neg_features <- coef2[which(as.numeric(coef2[[2]]) < 0), ]
pos_features <- subset(pos_features, Features != "Intercept")
neg_features <- subset(neg_features, Features != "Intercept")
max_len <- max(nrow(pos_features), nrow(neg_features))
pos_features <- pos_features[c(NA, seq_len(nrow(pos_features)), rep(NA, max_len - nrow(pos_features))), ]
neg_features <- neg_features[c(NA, seq_len(nrow(neg_features)), rep(NA, max_len - nrow(neg_features))), ]
empty_col <- c(intercept, rep(NA, max_len))
split_coefs <- cbind(pos_features, empty_col, neg_features)
split_coefs[is.na(split_coefs)] <- ""
colnames(split_coefs) <- c(paste0(classes2[2], " Features"),
paste0(classes2[2], " Weights"),
"Intercept",
paste0(classes2[1], " Features"),
paste0(classes2[1], " Weights"))
split_coefs %>%
kable(
row.names = FALSE,
align = "c",
linesep = ""
) %>%
kable_styling(full_width = F) %>%
column_spec(1:2,width = "1.5in") %>%
column_spec(3,width = "1in") %>%
column_spec(4:5,width = "1.5in")
## head to tail bar plot of features and weights
if (normalization_method == "median"){
max_y <- max(abs(as.numeric(coef2[2:nrow(coef2), 2])))
min_y <- -1*max(abs(as.numeric(coef2[2:nrow(coef2), 2])))
} else {
max_y <- round(max(abs(as.numeric(coef2[2:nrow(coef2), 2]))))
min_y <- -1*round(max(abs(as.numeric(coef2[2:nrow(coef2), 2]))))
}
coef3 <- coef2 %>%
mutate(fill = ifelse(as.numeric(coef2[, 2]) < 0, classes2[1], classes2[2]))
coef3$fill <- factor(coef3$fill, levels = classes2)
coef3 <- coef3[-c(1), ]
coef_plot <- ggplot(coef3,
aes(x = as.numeric(Features), y = as.numeric(coef3[, 2]), fill = fill)) +
geom_bar(stat = "identity", width = 2)+
labs(y = "Weights", x = expression(italic("m/z"))) +
coord_cartesian(xlim = mass_range, ylim = c(min_y, max_y)) +
scale_x_continuous(breaks = seq(mass_range[1], mass_range[2], by = 50), expand = c(0.01,0)) +
scale_y_continuous(limits = c(min_y, max_y), expand = c(0.01,0)) +
scale_fill_manual(values = cols) +
ggtitle("Model Feature Weights") +
theme_classic() +
guides(fill = guide_legend(byrow = TRUE)) +
theme(legend.title=element_blank(),
legend.background = element_rect(fill='transparent')) +
geom_hline(yintercept=0)
coef_plot
train_plot <- ggplot(train_df, aes(x=probability, fill=true_class, color=true_class)) +
geom_histogram(binwidth=0.01, alpha=0.25, position="identity",boundary=0) +
ggtitle("Model Prediction Probabilities: Training Set") +
geom_vline(xintercept = best_threshold, linewidth = 0.75,  color = "black", linetype = "dashed") +
scale_x_continuous(breaks = seq(0, 1, by = 0.1), minor_breaks = seq(0, 1, by = 0.05), expand = c(0.05,0)) +
scale_color_manual(values = cols, labels = c(classes2[1], classes2[2])) +
scale_fill_manual(values = cols, labels = c(classes2[1], classes2[2])) +
labs(x = "Prediction Probability", y = "Spectra Count", color="True Class", fill = "True Class") +
theme_minimal() +
theme(legend.position = "bottom")
test_plot <- ggplot(test_df, aes(x=probability, fill=true_class, color=true_class)) +
geom_histogram(binwidth=0.01, alpha=0.25, position="identity",boundary=0) +
ggtitle("Model Prediction Probabilities: Test Set") +
geom_vline(xintercept = best_threshold, linewidth = 0.75,  color = "black", linetype = "dashed") +
scale_x_continuous(breaks = seq(0, 1, by = 0.1), minor_breaks = seq(0, 1, by = 0.05), expand = c(0.05,0)) +
scale_color_manual(values = cols, labels = c(classes2[1], classes2[2])) +
scale_fill_manual(values = cols, labels = c(classes2[1], classes2[2])) +
labs(x = "Prediction Probability", y = "Spectra Count", color="True Class", fill = "True Class") +
theme_minimal() +
theme(legend.position = "bottom")
ggsave(plot=coef_plot, filename = file.path(files_dir, "coef_plot.png"),
width = 12,
height = 3,
units = "in",
dpi = 300)
ggsave(plot=train_plot, filename = file.path(files_dir, "train_histogram.png"), bg = "white")
ggsave(plot=test_plot, filename = file.path(files_dir, "test_histogram.png"), bg = "white")
ggsave(plot=train_plot, width = 1000, height = 800, res = 150, filename = file.path(files_dir, "train_histogram.png"), bg = "white")
ggsave(plot=train_plot, width = 1000 / 150, height = 800 / 150, dpi = 150, filename = file.path(files_dir, "train_histogram.png"), bg = "white")
train_plot <- ggplot(train_df, aes(x=probability, fill=true_class, color=true_class)) +
geom_histogram(binwidth=0.01, alpha=0.25, position="identity",boundary=0) +
ggtitle("Model Prediction Probabilities: Training Set") +
geom_vline(xintercept = best_threshold, linewidth = 0.75,  color = "black", linetype = "dashed") +
scale_x_continuous(breaks = seq(0, 1, by = 0.1), minor_breaks = seq(0, 1, by = 0.05), expand = c(0.05,0)) +
scale_color_manual(values = cols, labels = c(classes2[1], classes2[2])) +
scale_fill_manual(values = cols, labels = c(classes2[1], classes2[2])) +
labs(x = "Prediction Probability", y = "Spectra Count", color="True Class", fill = "True Class") +
theme_minimal() +
theme(legend.position = "right",
plot.title = element_text(hjust = 0.5, size = 16))
ggsave(plot=train_plot, width = 1000 / 150, height = 800 / 150, dpi = 150, filename = file.path(files_dir, "train_histogram.png"), bg = "white")
View(coef)
View(coef)
# Convert to data frame
coef_df <- data.frame(
feature = rownames(coefs),
weight = as.numeric(coefs)
)
# Convert to data frame
coef_df <- data.frame(
feature = rownames(coef),
weight = as.numeric(coef)
)
# Sort by weight to get top positive and negative features
top_cancer <- coef[order(-coef$weight), ][1:10, ]      # top positive weights
View(coef)
coef[order(coef$Cancer), ][1:10, ]
coef[order(-coef$Cancer), ][1:10, ]
View(aligned_spectra)
# Choose a sample (e.g., first row)
example_intensity <- aligned_spectra[1, ]  # or use row name: aligned_spectra["Sample_001", ]
# Get m/z values from column names
mz_values <- as.numeric(colnames(aligned_spectra))
# Create long-format data frame
spectrum_df <- data.frame(
mz = mz_values,
intensity = as.numeric(example_intensity)
)
# Optional: filter to reduce noise (e.g., keep intensities > threshold)
spectrum_df <- subset(spectrum_df, intensity > 0.01 * max(intensity))
library(ggplot2)
ggplot(spectrum_df, aes(x = mz, xend = mz, y = 0, yend = intensity)) +
geom_segment(size = 0.4) +
labs(
title = "Example Mass Spectrum (Single Sample)",
x = "m/z (mass-to-charge)",
y = "Relative Intensity"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 18, hjust = 0.5),
axis.title = element_text(size = 16),
axis.text = element_text(size = 14)
)
library(ggrepel)
top_peaks <- spectrum_df[order(-spectrum_df$intensity), ][1:5, ]
ggplot(spectrum_df, aes(x = mz, xend = mz, y = 0, yend = intensity)) +
geom_segment(size = 0.4) +
geom_text_repel(data = top_peaks, aes(x = mz, y = intensity, label = round(mz, 2)),
nudge_y = 0.05 * max(spectrum_df$intensity), size = 4) +
labs(title = "Example Mass Spectrum", x = "m/z", y = "Intensity") +
theme_minimal()
